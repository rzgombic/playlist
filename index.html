<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">

<style>
:root {
  --bg: #ffffff;
  --text: #000000;
  --panel: #f5f5f5;
  --border: #cccccc;
  --highlight: #dbeafe;
}

body.dark {
  --bg: #121212;
  --text: #eaeaea;
  --panel: #1e1e1e;
  --border: #333333;
  --highlight: #1f2937;
}

body {
  background: var(--bg);
  color: var(--text);
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
}

/* ---------- INPUT AREA ---------- */
#input-area {
  padding: 20px;
  background: white;
  border-bottom: 2px solid #ddd;
}

#text-input {
  width: 100%;
  padding: 12px;
  font-size: 14px;
  border: 1px solid #ccc;
  border-radius: 4px;
  resize: vertical;
  min-height: 120px;
  font-family: inherit;
}

#add-btn {
  margin-top: 10px;
  padding: 10px 20px;
  font-size: 14px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

#add-btn:hover {
  background: #0056b3;
}

#add-btn:active {
  transform: scale(0.98);
}

#add-btn:disabled {
  background: #ccc;
  cursor: not-allowed;
<<<<<<< Updated upstream
=======
}

#status-message {
  min-height: 20px;
}

#status-message.loading {
  color: #007bff;
}

#status-message.error {
  color: #dc3545;
}

#status-message.success {
  color: #28a745;
}

/* ---------- PLAYLIST AREA ---------- */
#playlist-area {
  padding: 20px;
  padding-bottom: 120px;
>>>>>>> Stashed changes
}

#status-message {
  min-height: 20px;
}

#status-message.loading {
  color: #007bff;
}

#status-message.error {
  color: #dc3545;
}

#status-message.success {
  color: #28a745;
}

/* ---------- PLAYLIST AREA ---------- */
#content {
  padding:
    calc(160px + env(safe-area-inset-top))
    0
    calc(160px + env(safe-area-inset-bottom));
}

ul {
  padding: 0;
  margin: 0;
}

li {
  list-style: none;
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 8px;
  border-bottom: 1px solid var(--border);
}

li.playing {
  background: var(--highlight);
  font-weight: 600;
}

.li-text {
  flex: 1;
  font-size: 14px;
  line-height: 1.4;
}

.del-btn {
  width: 32px;
  height: 32px;
  font-size: 16px;
  padding: 0;
}

/* ---------- CONTROLS (BOTTOM BAR) ---------- */
#controls {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  padding:
    10px 14px
    calc(10px + env(safe-area-inset-bottom));
  background: var(--panel);
  border-top: 1px solid var(--border);
  display: flex;
  align-items: center;
  gap: 14px;
}

.control-btn {
  width: 44px;
  height: 44px;
  font-size: 16px;
  padding: 0;
}

#progress {
  flex: 1;
  height: 4px;
}

.time-label {
  font-size: 12px;
  min-width: 42px;
  text-align: center;
  opacity: 0.8;
}

button, textarea {
  background: var(--panel);
  color: var(--text);
  border: 1px solid var(--border);
}

textarea {
  width: 100%;
  box-sizing: border-box;
  padding: 8px;
}
</style>
</head>

<body>

<!-- INPUT AREA -->
<div id="input-area">
  <textarea id="text-input" placeholder="Paste your article text or URL here..."></textarea>
  <button id="add-btn">Add to Playlist</button>
  <div id="status-message" style="margin-top: 10px; font-size: 13px; color: #666;"></div>
</div>

<!-- SCROLLABLE CONTENT -->
<div id="content">
  <ul id="list"></ul>
</div>

<!-- BOTTOM CONTROLS -->
<div id="controls">
  <button id="prev" class="control-btn">⏮</button>
  <button id="back10" class="control-btn">↺10</button>
  <button id="playpause" class="control-btn">▶︎</button>
  <button id="fwd10" class="control-btn">↻10</button>
  <button id="next" class="control-btn">⏭</button>

  <span id="elapsed" class="time-label">0:00</span>
  <progress id="progress" value="0" max="1"></progress>
  <span id="remaining" class="time-label">-0:00</span>

  <button id="speed">1.5×</button>
</div>

<script>
const textInput = document.getElementById('text-input');
const addBtn = document.getElementById('add-btn');
const playlist = document.getElementById('playlist');
const playPauseBtn = document.getElementById('play-pause-btn');
const prevBtn = document.getElementById('prev-btn');
const nextBtn = document.getElementById('next-btn');
const playAllBtn = document.getElementById('play-all-btn');
const statusMessage = document.getElementById('status-message');

let currentIndex = -1;
let items = [];
let isPlaying = false;
let progressInterval = null;
let startTime = 0;
let estimatedDuration = 0;
let pausedAt = 0;
let elapsedBeforePause = 0;

// ---------- UTILITY FUNCTIONS ----------
function isURL(str) {
  try {
    const url = new URL(str);
    return url.protocol === 'http:' || url.protocol === 'https:';
  } catch {
    return false;
  }
}

function setStatus(message, type = '') {
  statusMessage.textContent = message;
  statusMessage.className = type;
}

function clearStatus() {
  setTimeout(() => {
    statusMessage.textContent = '';
    statusMessage.className = '';
  }, 3000);
}

// ---------- URL SCRAPING ----------
async function scrapeURL(url) {
  try {
    // Use Textise.net to convert webpage to plain text
    const textiseURL = `https://www.textise.net/showText.aspx?strURL=${encodeURIComponent(url)}`;
    
    setStatus('Fetching content from URL...', 'loading');
    addBtn.disabled = true;
    
    const response = await fetch(textiseURL, {
      mode: 'cors'
    });
    
    if (!response.ok) {
      throw new Error('Failed to fetch content');
    }
    
    const html = await response.text();
    
    // Parse the Textise response
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Extract the main content from Textise
    const mainContent = doc.querySelector('#textblock') || doc.querySelector('body');
    
    if (!mainContent) {
      throw new Error('Could not extract content from page');
    }
    
    // Get text content and clean it up
    let text = mainContent.textContent || mainContent.innerText;
    text = text.trim();
    
    // Remove excessive whitespace and newlines
    text = text.replace(/\n\s*\n\s*\n/g, '\n\n');
    text = text.replace(/[ \t]+/g, ' ');
    
    if (!text || text.length < 50) {
      throw new Error('Extracted content is too short or empty');
    }
    
    return text;
    
  } catch (error) {
    console.error('Scraping error:', error);
    throw error;
  } finally {
    addBtn.disabled = false;
  }
}

// ---------- ADD ITEM ----------
addBtn.addEventListener('click', async () => {
  const input = textInput.value.trim();
  if (!input) return;
  
  try {
    let textToAdd = input;
    
    // Check if input is a URL
    if (isURL(input)) {
      try {
        textToAdd = await scrapeURL(input);
        setStatus('✓ Content extracted successfully!', 'success');
        clearStatus();
      } catch (error) {
        setStatus('✗ Could not scrape URL. Please copy and paste the article text manually instead.', 'error');
        alert(
          'Unable to scrape content from this URL.\n\n' +
          'This might happen because:\n' +
          '• The website blocks automated access\n' +
          '• The page requires login\n' +
          '• Network connectivity issues\n\n' +
          'Please try copying the article text directly and pasting it here instead.'
        );
        return;
      }
    }
    
    items.push(textToAdd);
    renderPlaylist();
    textInput.value = '';
    textInput.focus();
    
  } catch (error) {
    console.error('Error adding item:', error);
    setStatus('✗ An error occurred. Please try again.', 'error');
    clearStatus();
  }
});

// ---------- RENDER PLAYLIST ----------
function renderPlaylist() {
  playlist.innerHTML = '';
  
  items.forEach((text, index) => {
    const li = document.createElement('li');
    li.className = 'playlist-item';
    li.draggable = true;
    li.dataset.index = index;
    
    if (index === currentIndex) {
      li.classList.add('playing');
    }
    
    // Drag handle
    const handle = document.createElement('span');
    handle.className = 'drag-handle';
    handle.textContent = '☰';
    
    // Item content container
    const itemContent = document.createElement('div');
    itemContent.className = 'item-content';
    
    // Item text
    const itemText = document.createElement('div');
    itemText.className = 'item-text';
    itemText.textContent = text;
    
    // Duration
    const duration = calculateDuration(text);
    const durationEl = document.createElement('div');
    durationEl.className = 'item-duration';
    durationEl.textContent = formatDuration(duration);
    
    // Progress bar
    const progressContainer = document.createElement('div');
    progressContainer.className = 'item-progress';
    const progressBar = document.createElement('div');
    progressBar.className = 'item-progress-bar';
    progressContainer.appendChild(progressBar);
    
    itemContent.appendChild(itemText);
    itemContent.appendChild(durationEl);
    itemContent.appendChild(progressContainer);
    
    // Play button
    const playBtn = document.createElement('button');
    playBtn.className = 'play-item-btn';
    playBtn.textContent = '▶ Play';
    playBtn.addEventListener('click', () => playItem(index));
    
    // Delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '✕';
    deleteBtn.addEventListener('click', () => deleteItem(index));
    
    li.appendChild(handle);
    li.appendChild(itemContent);
    li.appendChild(playBtn);
    li.appendChild(deleteBtn);
    
    // Drag events
    li.addEventListener('dragstart', handleDragStart);
    li.addEventListener('dragover', handleDragOver);
    li.addEventListener('drop', handleDrop);
    li.addEventListener('dragend', handleDragEnd);
    
    playlist.appendChild(li);
  });
}

// ---------- DRAG AND DROP ----------
let draggedIndex = null;

function handleDragStart(e) {
  draggedIndex = parseInt(e.target.dataset.index);
  e.target.classList.add('dragging');
}

function handleDragOver(e) {
  e.preventDefault();
}

function handleDrop(e) {
  e.preventDefault();
  const dropIndex = parseInt(e.currentTarget.dataset.index);
  
  if (draggedIndex !== null && draggedIndex !== dropIndex) {
    // Reorder array
    const [draggedItem] = items.splice(draggedIndex, 1);
    items.splice(dropIndex, 0, draggedItem);
    
    // Update current index
    if (currentIndex === draggedIndex) {
      currentIndex = dropIndex;
    } else if (draggedIndex < currentIndex && dropIndex >= currentIndex) {
      currentIndex--;
    } else if (draggedIndex > currentIndex && dropIndex <= currentIndex) {
      currentIndex++;
    }
    
    renderPlaylist();
  }
}

function handleDragEnd(e) {
  e.target.classList.remove('dragging');
  draggedIndex = null;
}

/* ---------- SPEAK ---------- */
const speakFromOffset = () => {
  speechSynthesis.cancel()
  stopProgress()
  if (!currentText) return

  const remainingText = currentText.slice(currentOffset)
  const duration = secondsForText(remainingText)

  const u = new SpeechSynthesisUtterance(remainingText)
  u.rate = speed
  u.onend = () => playNext()
  startProgress(duration)
  speechSynthesis.speak(u)

  playPauseBtn.textContent = "❚❚"
  highlightCurrent()
}

/* ---------- PLAY CONTROLS ---------- */
const playIndex = i => {
  const items = [...list.children]
  if (!items[i]) return
  currentIndex = i
  currentText = items[i].dataset.text
  currentOffset = 0
  speakFromOffset()
}

const playNext = () => playIndex(currentIndex + 1)
const playPrev = () => playIndex(Math.max(0, currentIndex - 1))

/* ---------- SKIP ±10s ---------- */
const skipChars = () =>
  Math.floor(CHARS_PER_SEC * effectiveSpeed() * SKIP_SECONDS)

back10Btn.onclick = () => {
  currentOffset = Math.max(0, currentOffset - skipChars())
  speakFromOffset()
}

fwd10Btn.onclick = () => {
  currentOffset = Math.min(
    currentText.length,
    currentOffset + skipChars()
  )
  speakFromOffset()
}

/* ---------- BUTTON WIRING ---------- */
playPauseBtn.onclick = () => {
  if (speechSynthesis.speaking && !speechSynthesis.paused) {
    speechSynthesis.pause()
    playPauseBtn.textContent = "▶︎"
  } else if (speechSynthesis.paused) {
    speechSynthesis.resume()
    playPauseBtn.textContent = "❚❚"
  } else {
    playIndex(currentIndex >= 0 ? currentIndex : 0)
  }
}

nextBtn.onclick = playNext
prevBtn.onclick = playPrev

speedBtn.onclick = () => {
  speed = speed === 1 ? 1.5 : speed === 1.5 ? 2 : 1
  speedBtn.textContent = speed + "×"
  localStorage.setItem("speed", speed)
}

/* ---------- CHARACTER LIMIT ---------- */
t.oninput = () => {
  t.value = t.value.slice(0, MAX_CHARS)
  counter.textContent = `Chars: ${t.value.length} / ${MAX_CHARS}`
}

/* ---------- ADD / DELETE ITEMS ---------- */
const addItem = txt => {
  const li = document.createElement("li")
  li.dataset.text = txt

  const span = document.createElement("span")
  span.className = "li-text"
  span.textContent = txt

  const del = document.createElement("button")
  del.className = "del-btn"
  del.textContent = "✕"
  del.onclick = () => {
    const idx = [...list.children].indexOf(li)

    if (idx === currentIndex) {
      speechSynthesis.cancel()
      stopProgress()
      currentIndex = -1
      currentText = ""
    } else if (idx < currentIndex) {
      currentIndex--
    }

    li.remove()
    highlightCurrent()
    savePlaylist()
  }

  li.append(span, del)
  list.appendChild(li)
}

document.getElementById("add").onclick = () => {
  if (!t.value.trim()) return
  addItem(t.value.trim())
  savePlaylist()
  t.value = ""
  counter.textContent = `Chars: 0 / ${MAX_CHARS}`
}

/* ---------- RESTORE ---------- */
JSON.parse(localStorage.getItem("playlist") || "[]").forEach(addItem)
</script>

</body>
</html>
